{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "gql_globalid" }}

    {{ $usingGlobalID := false }}

    {{ range $n := $.Nodes }}
        {{ if $n.ID.Annotations.EntGQL.GlobalID }}
            {{ $usingGlobalID = true }}
        {{ else }}
            {{ if $usingGlobalID }}
                {{ fail "all ids should have entgql.GlobalID() annotation" }}
            {{ end }}
        {{ end }}
    {{ end }}

    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    {{ if $usingGlobalID }}

        const (
        {{- range $n := $.Nodes }}
            type{{ $n.Name }} = "{{ lower $n.Name }}"
        {{- end }}
        )

        // GlobalID is a global unique identifier that contains a a type and id.
        type GlobalID struct{ Type, ID string; resolvedType interface{} }

        var marshalGlobalID = func(g GlobalID) string {
        id := fmt.Sprintf("%s:%s", g.Type, g.ID)
        return base64.StdEncoding.EncodeToString([]byte(id))
        }

        var unmarshalGlobalID = func(v interface{}) (string, string, error) {
        id := v.(string)
        b, err := base64.URLEncoding.DecodeString(id)
        if err != nil {
        return "", "", err
        }
        tid := strings.Split(string(b), ":")
        if len(tid) != 2 {
        return "", "", fmt.Errorf("invalid global identifier format %q", b)
        }

        return tid[0], tid[1], nil
        }


        // UnmarshalGQL implements the interface graphql.Unmarshaler.
        func (g *GlobalID) UnmarshalGQL(v interface{}) error {
        typ, id, err := unmarshalGlobalID(v)
        if err != nil {
        return err
        }
        g.Type = typ
        g.ID =  id

        switch g.Type {
        {{- range $n := $.Nodes }}
            {{- if $n.ID.Type.Numeric }}
                case type{{ $n.Name }}:
                {{- if $n.ID.IsInt }}
                    rt, err := strconv.Atoi(g.ID)
                    if err != nil {
                    return err
                    }
                    g.resolvedType = rt
                    return nil
                {{- else }}
                    id, err := strconv.ParseInt(g.ID, 10, 64)
                    if err != nil {
                    return err
                    }
                    g.resolvedType = {{ if $n.ID.IsInt64 }}id{{ else }}{{ $n.ID.Type }}(id){{ end }}, nil
                    return nil
                {{- end }}
            {{ else if $n.ID.IsString }}
                case type{{ $n.Name }}:
                g.resolvedType = g.ID
                return nil
            {{ else if $n.ID.IsBytes }}
                case type{{ $n.Name }}:
                g.resolvedType = []byte(r.ID)
                return nil
            {{ else if $n.ID.IsUUID }}
                case type{{ $n.Name }}:
                var rt {{ $n.ID.Type }}
                if err := rt.UnmarshalText([]byte(g.ID)); err != nil {
                return err
                }
                g.resolvedType = rt
                return nil
            {{- end}}
        {{- end -}}
        }
        return fmt.Errorf("could not unmarshal the Global ID")
        }

        // MarshalGQL implements the interface graphql.Marshaler.
        func (g GlobalID) MarshalGQL(w io.Writer) {
        _, _ = w.Write([]byte(strconv.Quote(g.String())))
        }

        func (g GlobalID) String() string {
        return marshalGlobalID(g)
        }

        {{ $idTypes := dict }}
        {{ range $n := $.Nodes }}
            {{ if (hasKey $idTypes $n.ID.Type.String | not) }}
                {{ $idTypes = set $idTypes $n.ID.Type.String true }}
                {{ $typeName :=  $n.ID.Type.Type.String }}
                {{ if $n.ID.Type.RType }}
                    {{ $typeName = $n.ID.Type.RType.Name }}
                {{ end }}
                func (g *GlobalID) {{ pascal $typeName }}() {{ $n.ID.Type }} {
                return g.resolvedType.({{ $n.ID.Type }})
                }

                func GlobalIDsPtrTo{{ pascal $typeName }}s(ids []*GlobalID) []{{ $n.ID.Type }} {
                r := make([]{{ $n.ID.Type }}, 0, len(ids))
                for i := range ids {
                r = append(r, ids[i].{{ pascal $typeName }}())
                }
                return r
                }

                func GlobalIDsTo{{ pascal $typeName }}s(ids []GlobalID) []{{ $n.ID.Type }} {
                r := make([]{{ $n.ID.Type }}, 0, len(ids))
                for i := range ids {
                r = append(r, ids[i].{{ pascal $typeName }}())
                }
                return r
                }
            {{ end }}
        {{ end }}

        {{- range $n := $.Nodes }}
            // GlobalID returns the global identifier for the given {{ $n.Name }} node.
            func ({{ $n.Receiver }} *{{ $n.Name }}) GlobalID(ctx context.Context) GlobalID {
            return GlobalID{Type: type{{ $n.Name }}, ID: fmt.Sprintf("%{{ if $n.ID.Type.Numeric}}d{{ else }}s{{ end }}", {{ $n.Receiver }}.ID), resolvedType: {{ $n.Receiver }}.ID}
            }

            // New{{ $n.Name }}GlobalID creates a global identifier for the given {{ $n.Name }} node.
            func New{{ $n.Name }}GlobalID(id {{ $n.ID.Type }}) GlobalID {
            return GlobalID{Type: type{{ $n.Name }}, ID: fmt.Sprintf("%{{ if $n.ID.Type.Numeric}}d{{ else }}s{{ end }}", id), resolvedType: id}
            }
        {{- end }}

        // GlobalIDPtr returns a *GlobalID from the provided GlobalID.
        func GlobalIDPtr(g GlobalID) *GlobalID {
        return &g
        }


        func (c *Client) FromGlobalID(ctx context.Context, r GlobalID) (_ Noder, err error) {
        defer func() {
        if IsNotFound(err) {
        err = multierror.Append(err, entgql.ErrNodeNotFound(r.String()))
        }
        }()
        switch r.Type {
        {{- range $n := $.Nodes }}
            case type{{ $n.Name }}:
            {{- if $n.ID.Type.Numeric }}
                id:= r.{{ pascal $n.ID.Type.String }}()
            {{- else if $n.ID.IsUUID }}
                id := r.UUID()
            {{- else }}
                id := r.{{ if $n.ID.IsBytes }}Bytes(){{ else }}ID{{ end}}
            {{- end }}
            n, err := c.{{ $n.Name }}.Query().
            Where({{ $n.Package }}.ID(id)).
            {{- if hasTemplate "gql_collection" }}
                CollectFields(ctx, "{{ $n.Name }}").
            {{- end }}
            Only(ctx)
            if err != nil {
            return nil, err
            }
            return n, nil
        {{- end }}
        default:
        return nil, fmt.Errorf("cannot resolve noder of type %q: %w", r.Type, errNodeInvalidID)
        }
        }

        func (c *Client) FromGlobalIDs(ctx context.Context, ids []*GlobalID) (_ []Noder, err error) {
        switch len(ids) {
        case 1:
        noder, err := c.FromGlobalID(ctx, *ids[0])
        if err != nil {
        return nil, err
        }
        return []Noder{noder}, nil
        case 0:
        return []Noder{}, nil
        }
        noders := make([]Noder, len(ids))
        errors := make([]error, len(ids))
        types := make(map[string][]*GlobalID)
        id2idx := make(map[GlobalID][]int, len(ids))
        for i, id := range ids {
        if id == nil {
        continue
        }
        types[id.Type] = append(types[id.Type], id)
        id2idx[*id] = append(id2idx[*id], i)
        }

        for typ, ids := range types {
        nodes, err := c.nodes(ctx, typ, ids)
        if err != nil {
        for _, id := range ids {
        for _, idx := range id2idx[*id] {
        errors[idx] = err
        }
        }
        } else {
        for i, id := range ids {
        for _, idx := range id2idx[*id] {
        noders[idx] = nodes[i]
        }
        }
        }
        }

        for i, id := range ids {
        if errors[i] == nil {
        if noders[i] != nil {
        continue
        }
        errors[i] = entgql.ErrNodeNotFound(id)
        } else if IsNotFound(errors[i]) {
        errors[i] = multierror.Append(errors[i], entgql.ErrNodeNotFound(id))
        }
        ctx := graphql.WithPathContext(ctx,
        graphql.NewPathWithIndex(i),
        )
        graphql.AddError(ctx, errors[i])
        }
        return noders, nil
        }

        func (c *Client) nodes(ctx context.Context, typ string, rs []*GlobalID) ([]Noder, error) {
        noders := make([]Noder, len(rs))
        switch typ {
        {{- range $n := $.Nodes }}
            case type{{ $n.Name }}:
            {{- if $n.ID.Type.Numeric }}
                ids := make([]{{ $n.ID.Type }}, len(rs))
                for i := range ids {
                id := rs[i].{{ pascal $n.ID.Type.String }}()
                ids[i] = id
                }
            {{- else if $n.ID.IsUUID }}
                ids := make([]{{ $n.ID.Type }}, len(rs))
                for i := range ids {
                id := rs[i].UUID()
                ids[i] = id
                }
            {{- else }}
                ids := make([]{{ $n.ID.Type }}, len(rs))
                for i := range ids {
                ids[i] = rs[i].{{ if $n.ID.IsBytes }}Bytes(){{ else }}ID{{ end}}
                }
            {{- end }}
            idmap := make(map[{{ $n.ID.Type }}][]*Noder, len(ids))
            for i, id := range ids {
            idmap[id] = append(idmap[id], &noders[i])
            }
            nodes, err := c.{{ $n.Name }}.Query().
            Where({{ $n.Package }}.IDIn(ids...)).
            {{- if hasTemplate "gql_collection" }}
                CollectFields(ctx, "{{ $n.Name }}").
            {{- end }}
            All(ctx)
            if err != nil {
            return nil, err
            }
            for _, node := range nodes {
            for _, noder := range idmap[node.ID] {
            *noder = node
            }
            }
        {{- end }}
        default:
        return nil, fmt.Errorf("cannot resolve noders from type %q: %w", typ, errNodeInvalidID)
        }
        return noders, nil
        }
    {{ end }}
{{ end }}